/* CMSC 430 Compiler Theory and Design
   Project 3
   UMGC CITE
   Summer 2025
   Melbourne Anderson
   
   History ----->
   1.This is a file copy from Project 1
   2.Main method was removed - project 2 does not require a main method
   3.this file was updated from Project 2 to Project 3

   update: 2025-07-22
   4. includes were updated to match the new project structure
   5. removed duplicate real and {real}
   6. add doubleToInt function to convert double to int
   7. removed tokens.h from the includes because there is parser.tab.h
   8. issues with the real number literal were fixed after using rm -f lex.yy.c parser.tab.c *.o compile.exe
   which indicate cache issues with the generated files
   9. duplicate else definition found
    10. approach two - I backtracked to the merge action and included details up to the point that the file is now working
    11. added a new function to parse character literals and removing the old one individual escape sequences
    12. using a named pattern for escape sequences doesn't work as it can't be bound using braces{}
    12. add yylval.oper to the operators
    13. added yylval.oper for relational operators
    14. optional "==" equals relational operator
    15. added yylval.oper for more operators such as MODOP, EXPOP
    16. added yylval.oper for NOTEQUAL operator
    17. simplified the escape character literal parsing by using two rules instead of one
    18. updated the comment pattern to match the new comment style


    file breakdown ----->
    yylval.value - used for integer and char literals
    yylval.iden - used for identifiers (usually char*)
    yylval.oper - used for enums like ADD, MULTIPLY, etc.
    optional yylval.dbl - used for real literals

    workflow ----->
    1. declare the custom functions before the rules in the %{%} section
    2. define the custom functions after the rules in the %% section
    3. define the patterns in the named patterns section before the rules
    4. ECHO is used to output the matched text
    5. return the appropriate token with the yylval set to the value
    6. rule format is important, it should be in the form of:
       pattern { ECHO; yylval.value = ...; return TOKEN; }
    7. char      '.' - is used to match character literals
    8. debug rule format '\'(\\.|[^\\\'])\''     {ECHO; printf("Lexeme: %s Parsed char: %d\n", yytext, parse_char_literal(yytext)); fflush(stdout); yylval.value = parse_char_literal(yytext); return(CHAR_LITERAL);}// Regular characters

*/

/* This file contains flex input file */

%{
// System Dependencies
#include <stdio.h>      // for fileno
#include <string.h>     // for strcpy
#include <vector>       // for vector
#include <unistd.h>     // POSIX operating system API
using namespace std;    // Standard namespace

// Project Dependencies > order is important for compilation
#include "types.h"      // Defines Types enum, must come before parser.tab.h
#include "parser.tab.h" // Generated by Bison
#include "listing.h"    // Error reporting
%}

%option noyywrap

ws		[ \t\r]+
comment		"//".*\n|"--".*\n 
line		[\n]
id		[a-zA-Z_][a-zA-Z0-9_]*
digit		[0-9]
dec		{digit}+
char      '.'
punc		[\(\),:;]
hex     \#[0-9a-fA-F]+
real  ({digit}+\.[0-9]*([eE][+-]?{digit}+)?|\.[0-9]+([eE][+-]?{digit}+)?)

%%
"real"    { ECHO; return REAL; } // keyword for type REAL in parser
{real} { ECHO; yylval.type = REAL_TYPE; return(REAL_LITERAL); } // numeric value based on pattern
{hex}    { ECHO; yylval.type = HEX_TYPE; return(HEX_LITERAL); } // TODO -- add HEX_TYPE to types.h 
"if" {ECHO; return IF;}
"then" {ECHO; return THEN;}
"else" {ECHO; return ELSE;}
"elsif" {ECHO; return ELSIF;}
"fold" {ECHO; return FOLD;}
"left" { ECHO; return LEFT; } // Direction for fold > semantic action //TODO -- add LEFT_TYPE to types.h
"right" { ECHO; return RIGHT; } // Direction for fold > semantic action //TODO -- add RIGHT_TYPE to types.h
"endfold" {ECHO; return ENDFOLD;}
"endif" {ECHO; return ENDIF;}
"^"   { ECHO; return EXPOP; } //Logical Exponent
"|"     { ECHO; return OROP; }  // Logical OR
"!"     { ECHO; return NOTOP; } // Logical NOT
"%"     { ECHO; return MODOP; }     // Modulus
"~"     { ECHO; return NEGOP; }     // Bitwise or custom negation
"<>"    { ECHO; return (RELOP); }     // Not equals
"/"    { ECHO; return (MULOP); }     // Division
"+"		{ ECHO; return(ADDOP); }
"*"		{ ECHO; return(MULOP); }
"-"		{ ECHO; return(ADDOP); } // Substraction
"&"		{ ECHO; return(ANDOP); }
"=>"    { ECHO; return (ARROW); }    
">="    { ECHO; return (RELOP); } //Comparison > fixed missing ECHO
"<="		{ ECHO; return (RELOP); } // Less than or equal
"=<"     { ECHO; return (RELOP); } //alternative form for Less than or equal 
"<"		{ ECHO; return(RELOP); } // Less than
">"     { ECHO; return (RELOP); }     // Greater than
"="     { ECHO; return (RELOP); }     // Equals
{ws}		{ ECHO; }
{comment}	{ ECHO; nextLine(); }
{line}		{ ECHO; nextLine(); }
":"      {ECHO; return ':'; } // necessary for the parser >colon
begin		{ ECHO; return(BEGIN_); }
case		{ ECHO; return(CASE); }
character	{ ECHO; return(CHARACTER); } // keyword for character type in parser
end		{ ECHO; return(END); }
endswitch	{ ECHO; return(ENDSWITCH); }
function	{ ECHO; return(FUNCTION); }
integer		{ ECHO; return(INTEGER); } // keyword for integer type in parser
is		{ ECHO; return(IS); }
list		{ ECHO; return(LIST); }
of		{ ECHO; return(OF); }
others		{ ECHO; return(OTHERS); }
returns		{ ECHO; return(RETURNS); }
switch		{ ECHO; return(SWITCH); }
when		{ ECHO; return(WHEN); }
{dec}		{ ECHO; yylval.type = INT_TYPE; return(INT_LITERAL); } //changed from yylval.dbl to yylval.type //part of change 1.2
'\\.'   {ECHO; yylval.type = CHAR_TYPE; return(CHAR_LITERAL);} // escape character literal
'\''[^\\']'\''   {ECHO; yylval.type = CHAR_TYPE; return(CHAR_LITERAL);} // Character literal with single quotes
{char}		{ ECHO; yylval.type = CHAR_TYPE; return(CHAR_LITERAL); } //changed from yylval.value to yylval.type //part of change 1.2
{id}     { ECHO; yylval.iden = (CharPtr)malloc(yyleng + 1); strcpy(yylval.iden, yytext); return(IDENTIFIER);}
{punc}		{ ECHO; return(yytext[0]); } // Punctuation characters, it should be placed just before the catch-all rule
.             { ECHO; appendError(LEXICAL, yytext); } // Catch-all for any other character
%%